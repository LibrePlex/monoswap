/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Address } from '@solana/addresses';
import {
  Codec,
  Decoder,
  Encoder,
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  mapEncoder,
} from '@solana/codecs';
import {
  IAccountMeta,
  IInstruction,
  IInstructionWithAccounts,
  IInstructionWithData,
  ReadonlyAccount,
  ReadonlySignerAccount,
  WritableAccount,
  WritableSignerAccount,
} from '@solana/instructions';
import { IAccountSignerMeta, TransactionSigner } from '@solana/signers';
import { MONOSWAP_PROGRAM_ADDRESS } from '../programs';
import { ResolvedAccount, getAccountMetaFactory } from '../shared';

export type SwapSPLInstruction<
  TProgram extends string = typeof MONOSWAP_PROGRAM_ADDRESS,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountAuthority extends string | IAccountMeta<string> = string,
  TAccountSwapMarker extends string | IAccountMeta<string> = string,
  TAccountEscrowedAsset extends string | IAccountMeta<string> = string,
  TAccountIncomingAsset extends string | IAccountMeta<string> = string,
  TAccountSwapMarkerEscrowedAta extends string | IAccountMeta<string> = string,
  TAccountSwapMarkerIncomingAta extends string | IAccountMeta<string> = string,
  TAccountOutgoingAssetAta extends string | IAccountMeta<string> = string,
  TAccountIncomingAssetAta extends string | IAccountMeta<string> = string,
  TAccountEscrowedAssetProgram extends string | IAccountMeta<string> = string,
  TAccountIncomingAssetProgram extends string | IAccountMeta<string> = string,
  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            IAccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountSwapMarker extends string
        ? WritableAccount<TAccountSwapMarker>
        : TAccountSwapMarker,
      TAccountEscrowedAsset extends string
        ? WritableAccount<TAccountEscrowedAsset>
        : TAccountEscrowedAsset,
      TAccountIncomingAsset extends string
        ? WritableAccount<TAccountIncomingAsset>
        : TAccountIncomingAsset,
      TAccountSwapMarkerEscrowedAta extends string
        ? WritableAccount<TAccountSwapMarkerEscrowedAta>
        : TAccountSwapMarkerEscrowedAta,
      TAccountSwapMarkerIncomingAta extends string
        ? WritableAccount<TAccountSwapMarkerIncomingAta>
        : TAccountSwapMarkerIncomingAta,
      TAccountOutgoingAssetAta extends string
        ? WritableAccount<TAccountOutgoingAssetAta>
        : TAccountOutgoingAssetAta,
      TAccountIncomingAssetAta extends string
        ? WritableAccount<TAccountIncomingAssetAta>
        : TAccountIncomingAssetAta,
      TAccountEscrowedAssetProgram extends string
        ? ReadonlyAccount<TAccountEscrowedAssetProgram>
        : TAccountEscrowedAssetProgram,
      TAccountIncomingAssetProgram extends string
        ? ReadonlyAccount<TAccountIncomingAssetProgram>
        : TAccountIncomingAssetProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type SwapSPLInstructionData = { discriminator: number };

export type SwapSPLInstructionDataArgs = {};

export function getSwapSPLInstructionDataEncoder(): Encoder<SwapSPLInstructionDataArgs> {
  return mapEncoder(
    getStructEncoder([['discriminator', getU8Encoder()]]),
    (value) => ({ ...value, discriminator: 2 })
  );
}

export function getSwapSPLInstructionDataDecoder(): Decoder<SwapSPLInstructionData> {
  return getStructDecoder([['discriminator', getU8Decoder()]]);
}

export function getSwapSPLInstructionDataCodec(): Codec<
  SwapSPLInstructionDataArgs,
  SwapSPLInstructionData
> {
  return combineCodec(
    getSwapSPLInstructionDataEncoder(),
    getSwapSPLInstructionDataDecoder()
  );
}

export type SwapSPLInput<
  TAccountPayer extends string = string,
  TAccountAuthority extends string = string,
  TAccountSwapMarker extends string = string,
  TAccountEscrowedAsset extends string = string,
  TAccountIncomingAsset extends string = string,
  TAccountSwapMarkerEscrowedAta extends string = string,
  TAccountSwapMarkerIncomingAta extends string = string,
  TAccountOutgoingAssetAta extends string = string,
  TAccountIncomingAssetAta extends string = string,
  TAccountEscrowedAssetProgram extends string = string,
  TAccountIncomingAssetProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  /** Account to pay for ATA creation */
  payer: TransactionSigner<TAccountPayer>;
  /** Authority to transfer incoming asset */
  authority: TransactionSigner<TAccountAuthority>;
  /** Escrows the asset and encodes state about the swap */
  swapMarker: Address<TAccountSwapMarker>;
  /** The currently escrowed asset */
  escrowedAsset: Address<TAccountEscrowedAsset>;
  /** External asset being swapped for the escrowed asset */
  incomingAsset: Address<TAccountIncomingAsset>;
  /** The ATA for the escrowed asset and Swap Marker */
  swapMarkerEscrowedAta: Address<TAccountSwapMarkerEscrowedAta>;
  /** The ATA for the incoming asset and Swap Marker */
  swapMarkerIncomingAta: Address<TAccountSwapMarkerIncomingAta>;
  /** ATA for the escrowed asset and authority */
  outgoingAssetAta: Address<TAccountOutgoingAssetAta>;
  /** ATA for the incoming asset and authority */
  incomingAssetAta: Address<TAccountIncomingAssetAta>;
  /** Transfer Program ID of the incoming asset */
  escrowedAssetProgram: Address<TAccountEscrowedAssetProgram>;
  /** Transfer Program ID of the external asset */
  incomingAssetProgram: Address<TAccountIncomingAssetProgram>;
  /** The SPL associated token program account program */
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
  /** System program account */
  systemProgram?: Address<TAccountSystemProgram>;
};

export function getSwapSPLInstruction<
  TAccountPayer extends string,
  TAccountAuthority extends string,
  TAccountSwapMarker extends string,
  TAccountEscrowedAsset extends string,
  TAccountIncomingAsset extends string,
  TAccountSwapMarkerEscrowedAta extends string,
  TAccountSwapMarkerIncomingAta extends string,
  TAccountOutgoingAssetAta extends string,
  TAccountIncomingAssetAta extends string,
  TAccountEscrowedAssetProgram extends string,
  TAccountIncomingAssetProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TAccountSystemProgram extends string,
>(
  input: SwapSPLInput<
    TAccountPayer,
    TAccountAuthority,
    TAccountSwapMarker,
    TAccountEscrowedAsset,
    TAccountIncomingAsset,
    TAccountSwapMarkerEscrowedAta,
    TAccountSwapMarkerIncomingAta,
    TAccountOutgoingAssetAta,
    TAccountIncomingAssetAta,
    TAccountEscrowedAssetProgram,
    TAccountIncomingAssetProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >
): SwapSPLInstruction<
  typeof MONOSWAP_PROGRAM_ADDRESS,
  TAccountPayer,
  TAccountAuthority,
  TAccountSwapMarker,
  TAccountEscrowedAsset,
  TAccountIncomingAsset,
  TAccountSwapMarkerEscrowedAta,
  TAccountSwapMarkerIncomingAta,
  TAccountOutgoingAssetAta,
  TAccountIncomingAssetAta,
  TAccountEscrowedAssetProgram,
  TAccountIncomingAssetProgram,
  TAccountAssociatedTokenProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = MONOSWAP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    swapMarker: { value: input.swapMarker ?? null, isWritable: true },
    escrowedAsset: { value: input.escrowedAsset ?? null, isWritable: true },
    incomingAsset: { value: input.incomingAsset ?? null, isWritable: true },
    swapMarkerEscrowedAta: {
      value: input.swapMarkerEscrowedAta ?? null,
      isWritable: true,
    },
    swapMarkerIncomingAta: {
      value: input.swapMarkerIncomingAta ?? null,
      isWritable: true,
    },
    outgoingAssetAta: {
      value: input.outgoingAssetAta ?? null,
      isWritable: true,
    },
    incomingAssetAta: {
      value: input.incomingAssetAta ?? null,
      isWritable: true,
    },
    escrowedAssetProgram: {
      value: input.escrowedAssetProgram ?? null,
      isWritable: false,
    },
    incomingAssetProgram: {
      value: input.incomingAssetProgram ?? null,
      isWritable: false,
    },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.swapMarker),
      getAccountMeta(accounts.escrowedAsset),
      getAccountMeta(accounts.incomingAsset),
      getAccountMeta(accounts.swapMarkerEscrowedAta),
      getAccountMeta(accounts.swapMarkerIncomingAta),
      getAccountMeta(accounts.outgoingAssetAta),
      getAccountMeta(accounts.incomingAssetAta),
      getAccountMeta(accounts.escrowedAssetProgram),
      getAccountMeta(accounts.incomingAssetProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getSwapSPLInstructionDataEncoder().encode({}),
  } as SwapSPLInstruction<
    typeof MONOSWAP_PROGRAM_ADDRESS,
    TAccountPayer,
    TAccountAuthority,
    TAccountSwapMarker,
    TAccountEscrowedAsset,
    TAccountIncomingAsset,
    TAccountSwapMarkerEscrowedAta,
    TAccountSwapMarkerIncomingAta,
    TAccountOutgoingAssetAta,
    TAccountIncomingAssetAta,
    TAccountEscrowedAssetProgram,
    TAccountIncomingAssetProgram,
    TAccountAssociatedTokenProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedSwapSPLInstruction<
  TProgram extends string = typeof MONOSWAP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Account to pay for ATA creation */
    payer: TAccountMetas[0];
    /** Authority to transfer incoming asset */
    authority: TAccountMetas[1];
    /** Escrows the asset and encodes state about the swap */
    swapMarker: TAccountMetas[2];
    /** The currently escrowed asset */
    escrowedAsset: TAccountMetas[3];
    /** External asset being swapped for the escrowed asset */
    incomingAsset: TAccountMetas[4];
    /** The ATA for the escrowed asset and Swap Marker */
    swapMarkerEscrowedAta: TAccountMetas[5];
    /** The ATA for the incoming asset and Swap Marker */
    swapMarkerIncomingAta: TAccountMetas[6];
    /** ATA for the escrowed asset and authority */
    outgoingAssetAta: TAccountMetas[7];
    /** ATA for the incoming asset and authority */
    incomingAssetAta: TAccountMetas[8];
    /** Transfer Program ID of the incoming asset */
    escrowedAssetProgram: TAccountMetas[9];
    /** Transfer Program ID of the external asset */
    incomingAssetProgram: TAccountMetas[10];
    /** The SPL associated token program account program */
    associatedTokenProgram?: TAccountMetas[11] | undefined;
    /** System program account */
    systemProgram: TAccountMetas[12];
  };
  data: SwapSPLInstructionData;
};

export function parseSwapSPLInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedSwapSPLInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === MONOSWAP_PROGRAM_ADDRESS
      ? undefined
      : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      authority: getNextAccount(),
      swapMarker: getNextAccount(),
      escrowedAsset: getNextAccount(),
      incomingAsset: getNextAccount(),
      swapMarkerEscrowedAta: getNextAccount(),
      swapMarkerIncomingAta: getNextAccount(),
      outgoingAssetAta: getNextAccount(),
      incomingAssetAta: getNextAccount(),
      escrowedAssetProgram: getNextAccount(),
      incomingAssetProgram: getNextAccount(),
      associatedTokenProgram: getNextOptionalAccount(),
      systemProgram: getNextAccount(),
    },
    data: getSwapSPLInstructionDataDecoder().decode(instruction.data),
  };
}
